local __util = require 'larian.util'

function HasBattleMagic(entity)
    local entity = entity or context.Target
	local result = HasAnyStatus({'SPELLBINDER_EXTRA_ATTACK_CANTRIP', 'SPELLBINDER_EXTRA_ATTACK'},{},{}, entity, context.Source, false).Result
    return ConditionResult(result)
end

function SpellAutoResolveOnAllyWithDisadvantage(ability, dc, result)
    result = result or false
    ally = Ally()
    if not ally.Result then
        st = ~SavingThrow(ability, dc, false, true)
        return ConditionResult(st.Result,{},{},st.Chance)
    end
    return ConditionResult(result)
end

function CanQuickBind()
    if HasUseCosts('ActionPoint').Result and not HasUseCosts('BonusActionPoint').Result then
        local spellId = context.SpellModificationDescription.SpellId
        if spellId ~= "" and string.find(spellId, "Shout_Spellbinder_Bind") then
            return ConditionResult(true)
        end
    end
    return ConditionResult(false)
end

function GetBindCost()
    return context.HitDescription.SpellPowerLevel + 1
end

function BoundRangedSpellCheck()
    if HasPassive('Spellbinder_ArcaneSniper_TelekineticProjectiles',context.Source).Result then
        local mainHandEntity = GetItemInEquipmentSlot(EquipmentSlot.RangedMainHand, context.Source)
        if mainHandEntity.IsValid then
            return Tagged('SPELLBINDER_BOUND', mainHandEntity) & HasStringInSpellRoll('RangedWeaponAttack')
        end
    end
    return ConditionResult(false)
end

function BoundRangedOffHandSpellCheck()
    if HasPassive('Spellbinder_ArcaneSniper_TelekineticProjectiles',context.Source).Result then
        local offHandEntity = GetItemInEquipmentSlot(EquipmentSlot.RangedOffHand, context.Source)
        if offHandEntity.IsValid then
            return Tagged('SPELLBINDER_BOUND', offHandEntity) & HasStringInSpellRoll('RangedOffHandWeaponAttack') & ~HasStringInSpellRoll('RangedWeaponAttack')
        end
    end
    return ConditionResult(false)
end